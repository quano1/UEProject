// Copyright Epic Games, Inc. All Rights Reserved.

#include "ToolTargets/TLLRN_SkeletalMeshToolTarget.h"

#include "LODUtilities.h"
#include "ConversionUtils/DynamicMeshViaMeshDescriptionUtil.h"
#include "DynamicMesh/DynamicMesh3.h"
#include "Engine/SkinnedAssetCommon.h"
#include "Rendering/SkeletalMeshModel.h"
#include "Widgets/Notifications/SNotificationList.h"
#include "Framework/Notifications/NotificationManager.h"
#include "ModelingToolTargetUtil.h"
#include "SkeletalMeshAttributes.h"
#include "Misc/SlowTask.h"
#include "UObject/Package.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(TLLRN_SkeletalMeshToolTarget)

using namespace UE::Geometry;

#define LOCTEXT_NAMESPACE "TLLRN_SkeletalMeshToolTarget"


namespace TLLRN_SkeletalMeshToolTargetLocals
{
static void DisplayCriticalWarningMessage(const FText& InMessage)
{
	FNotificationInfo Info(InMessage);
	Info.ExpireDuration = 5.0f;
	FSlateNotificationManager::Get().AddNotification(Info);

	UE_LOG(LogGeometry, Warning, TEXT("%s"), *InMessage.ToString());
}
}


//
// UTLLRN_SkeletalMeshReadOnlyToolTarget
//


bool UTLLRN_SkeletalMeshReadOnlyToolTarget::IsValid() const
{
	return SkeletalMesh.IsValid();
}

bool UTLLRN_SkeletalMeshReadOnlyToolTarget::IsValid(const USkeletalMesh* SkeletalMeshIn)
{
	if (!SkeletalMeshIn || !IsValidChecked(SkeletalMeshIn) || SkeletalMeshIn->IsUnreachable() || !SkeletalMeshIn->IsValidLowLevel())
	{
		return false;
	}

	return true;
}

TArray<EMeshLODIdentifier> UTLLRN_SkeletalMeshReadOnlyToolTarget::GetAvailableLODs(const USkeletalMesh* SkeletalMesh, bool bSkipAutoGenerated)
{
	TArray<EMeshLODIdentifier> AvailableLODs;

	if (!SkeletalMesh)
	{
		return AvailableLODs;
	}

	const int32 MaxLODs = FMath::Min(8, SkeletalMesh->GetNumSourceModels());

	for (int32 LODIndex = 0; LODIndex < MaxLODs; LODIndex++)
	{
		if (bSkipAutoGenerated && !SkeletalMesh->HasMeshDescription(LODIndex))
		{
			continue;
		}

		AvailableLODs.Add(static_cast<EMeshLODIdentifier>(LODIndex));
	}

	return AvailableLODs;
}

int32 UTLLRN_SkeletalMeshReadOnlyToolTarget::GetNumMaterials() const
{
	return ensure(IsValid()) ? SkeletalMesh->GetMaterials().Num() : 0;
}

UMaterialInterface* UTLLRN_SkeletalMeshReadOnlyToolTarget::GetMaterial(int32 MaterialIndex) const
{
	return ensure(IsValid() && MaterialIndex < SkeletalMesh->GetMaterials().Num()) ? 
		SkeletalMesh->GetMaterials()[MaterialIndex].MaterialInterface : nullptr;
}

void UTLLRN_SkeletalMeshReadOnlyToolTarget::GetMaterialSet(FComponentMaterialSet& MaterialSetOut, bool bPreferAssetMaterials) const
{
	if (!ensure(IsValid())) return;
	GetMaterialSet(SkeletalMesh.Get(), MaterialSetOut, bPreferAssetMaterials);
}

void UTLLRN_SkeletalMeshReadOnlyToolTarget::GetMaterialSet(const USkeletalMesh* SkeletalMeshIn, FComponentMaterialSet& MaterialSetOut,
	bool bPreferAssetMaterials)
{
	const TArray<FSkeletalMaterial>& Materials = SkeletalMeshIn->GetMaterials(); 
	MaterialSetOut.Materials.SetNum(Materials.Num());
	for (int32 k = 0; k < Materials.Num(); ++k)
	{
		MaterialSetOut.Materials[k] = Materials[k].MaterialInterface;
	}
}

bool UTLLRN_SkeletalMeshReadOnlyToolTarget::CommitMaterialSetUpdate(const FComponentMaterialSet& MaterialSet, bool bApplyToAsset)
{
	if (!ensure(IsValid())) return false;
	return CommitMaterialSetUpdate(SkeletalMesh.Get(), MaterialSet, bApplyToAsset);
}

bool UTLLRN_SkeletalMeshReadOnlyToolTarget::CommitMaterialSetUpdate(USkeletalMesh* SkeletalMeshIn, 
	const FComponentMaterialSet& MaterialSet, bool bApplyToAsset)
{
	if (!bApplyToAsset)
	{
		return false;
	}

	if (SkeletalMeshIn->GetPathName().StartsWith(TEXT("/Engine/")))
	{
		UE_LOG(LogTemp, Warning, TEXT("CANNOT MODIFY BUILT-IN ENGINE ASSET %s"), *SkeletalMeshIn->GetPathName());
		return false;
	}

	// flush any pending rendering commands, which might touch a component while we are rebuilding its mesh
	FlushRenderingCommands();

	// make sure transactional flag is on
	SkeletalMeshIn->SetFlags(RF_Transactional);

	SkeletalMeshIn->Modify();

	const int NewNumMaterials = MaterialSet.Materials.Num();
	TArray<FSkeletalMaterial> &SkeletalMaterials = SkeletalMeshIn->GetMaterials(); 
	if (NewNumMaterials != SkeletalMaterials.Num())
	{
		SkeletalMaterials.SetNum(NewNumMaterials);
	}
	for (int k = 0; k < NewNumMaterials; ++k)
	{
		if (SkeletalMaterials[k].MaterialInterface != MaterialSet.Materials[k])
		{
			SkeletalMaterials[k].MaterialInterface = MaterialSet.Materials[k];
			if (SkeletalMaterials[k].MaterialSlotName.IsNone())
			{
				SkeletalMaterials[k].MaterialSlotName = MaterialSet.Materials[k]->GetFName();
			}
		}
	}

	UE::ToolTarget::Internal::PostEditChangeWithConditionalUndo(SkeletalMeshIn);

	return true;
}

int32 UTLLRN_SkeletalMeshReadOnlyToolTarget::GetValidEditingLOD(const USkeletalMesh* SkeletalMesh, int32 DefaultEditingLOD, bool bHaveRequestLOD, EMeshLODIdentifier RequestedEditingLOD)
{
	using namespace TLLRN_SkeletalMeshToolTargetLocals;

	int32 ValidEditingLOD = DefaultEditingLOD;

	if (bHaveRequestLOD)
	{
		if (RequestedEditingLOD == EMeshLODIdentifier::MaxQuality)
		{
			ValidEditingLOD = 0;
		}
		else if (RequestedEditingLOD == EMeshLODIdentifier::HiResSource)
		{
			DisplayCriticalWarningMessage(LOCTEXT("SkelmeshHiresLODUnavailable", "HiRes LOD not available on skeletal meshes. Falling back to using LOD 0."));
		}
		else if (RequestedEditingLOD != EMeshLODIdentifier::Default)
		{
			ValidEditingLOD = static_cast<int32>(RequestedEditingLOD);
		}
	}
	
	const int32 MaxLOD = SkeletalMesh->GetLODNum() - 1;
	if (ValidEditingLOD > MaxLOD)
	{
		DisplayCriticalWarningMessage(FText::Format(LOCTEXT("SkelmeshLODUnavailable", "LOD {0} requested but is not available. Falling back to LOD {1}."), FText::AsNumber(ValidEditingLOD), FText::AsNumber(MaxLOD)));
		ValidEditingLOD = MaxLOD;
	}

	return ValidEditingLOD;
}

const FMeshDescription* UTLLRN_SkeletalMeshReadOnlyToolTarget::GetMeshDescription(const FGetMeshParameters& GetMeshParams)
{
	if (ensure(IsValid()))
	{
		const int32 LODIndex = GetValidEditingLOD(SkeletalMesh.Get(), DefaultEditingLOD, GetMeshParams.bHaveRequestLOD, GetMeshParams.RequestLOD);
	
		return SkeletalMesh->GetMeshDescription(LODIndex);
	}

	return nullptr;
}


FMeshDescription UTLLRN_SkeletalMeshReadOnlyToolTarget::GetEmptyMeshDescription()
{
	FMeshDescription EmptyMeshDescription;
	FSkeletalMeshAttributes MeshAttributes(EmptyMeshDescription);
	MeshAttributes.Register();

	return EmptyMeshDescription;
}

TArray<EMeshLODIdentifier> UTLLRN_SkeletalMeshReadOnlyToolTarget::GetAvailableLODs(bool bSkipAutoGenerated) const
{
	return GetAvailableLODs(SkeletalMesh.Get(), bSkipAutoGenerated);
}

FDynamicMesh3 UTLLRN_SkeletalMeshReadOnlyToolTarget::GetDynamicMesh()
{
	return GetDynamicMeshViaMeshDescription(*this);
}

FDynamicMesh3 UTLLRN_SkeletalMeshReadOnlyToolTarget::GetDynamicMesh(const FGetMeshParameters& InGetMeshParams)
{
	return GetDynamicMeshViaMeshDescription(*this, InGetMeshParams);
}

USkeletalMesh* UTLLRN_SkeletalMeshReadOnlyToolTarget::GetSkeletalMesh() const
{
	return IsValid() ? SkeletalMesh.Get() : nullptr;
}

//
// UTLLRN_SkeletalMeshToolTarget
//

void UTLLRN_SkeletalMeshToolTarget::CommitMeshDescription(const FCommitter& Committer, const FCommitMeshParameters& CommitMeshParams)
{
	if (ensure(IsValid()))
	{
		const int32 LODIndex = GetValidEditingLOD(SkeletalMesh.Get(), DefaultEditingLOD, CommitMeshParams.bHaveTargetLOD, CommitMeshParams.TargetLOD);
		
		CommitMeshDescription(SkeletalMesh.Get(), Committer, LODIndex);
	}
}

void UTLLRN_SkeletalMeshToolTarget::CommitMeshDescription(USkeletalMesh* SkeletalMesh, const FCommitter& Committer, int32 LODIndex)
{
	using namespace TLLRN_SkeletalMeshToolTargetLocals;

	if (SkeletalMesh->GetPathName().StartsWith(TEXT("/Engine/")))
	{
		DisplayCriticalWarningMessage(FText::Format(LOCTEXT("CannotModifyBuiltInAssetError", "Cannot modify built-in engine asset: {0}"), FText::FromString(*SkeletalMesh->GetPathName())));
		return;
	}

	// flush any pending rendering commands, which might touch a component while we are rebuilding it's mesh
	FlushRenderingCommands();

	// Ensure the asset is set to transactional, so that undo works proper.
	SkeletalMesh->SetFlags(RF_Transactional);
	SkeletalMesh->Modify();

	// Mark the mesh at this LOD as modified as well, so that we can undo any geometry changes.
	SkeletalMesh->ModifyMeshDescription(LODIndex);
	
	FCommitterParams CommitterParams;
	CommitterParams.MeshDescriptionOut = SkeletalMesh->GetMeshDescription(LODIndex);
	Committer(CommitterParams);

	// Commit the edited mesh description to bulk data.
	SkeletalMesh->CommitMeshDescription(LODIndex);

	// Update the vertex attribute infos now that we have committed the mesh description
	// the actual copying from SourceModel to LODModel happens during build time
	FLODUtilities::UpdateLODInfoVertexAttributes(SkeletalMesh, LODIndex, LODIndex, false);
	
	// This call will invoke the skeletal mesh render data rebuild machinery.
	UE::ToolTarget::Internal::PostEditChangeWithConditionalUndo(SkeletalMesh);
}

void UTLLRN_SkeletalMeshToolTarget::CommitDynamicMesh(const FDynamicMesh3& Mesh, const FDynamicMeshCommitInfo& CommitInfo)
{
	FMeshDescription CurrentMeshDescription = *GetMeshDescription();
	CommitDynamicMeshViaMeshDescription(MoveTemp(CurrentMeshDescription), *this, Mesh, CommitInfo);
}


// Factory

bool UTLLRN_SkeletalMeshReadOnlyToolTargetFactory::CanBuildTarget(UObject* SourceObject, const FToolTargetTypeRequirements& Requirements) const
{
	// We are using an exact cast here to prevent subclasses, which might not meet all
	// requirements for functionality such as the deprecated DestructibleMesh, from 
	// being caught up as valid targets.
	// If you want to make the tool target work with some subclass of USkeletalMesh,
	// just add another factory that allows that class specifically (but make sure that
	// GetMeshDescription and such work properly)

	const USkeletalMesh* SkeletalMesh =  ExactCast<USkeletalMesh>(SourceObject);

	return SkeletalMesh
		&& !SkeletalMesh->GetOutermost()->bIsCookedForEditor
		&& Requirements.AreSatisfiedBy(UTLLRN_SkeletalMeshReadOnlyToolTarget::StaticClass());
}

UToolTarget* UTLLRN_SkeletalMeshReadOnlyToolTargetFactory::BuildTarget(UObject* SourceObject, const FToolTargetTypeRequirements& Requirements)
{
	UTLLRN_SkeletalMeshReadOnlyToolTarget* Target = NewObject<UTLLRN_SkeletalMeshReadOnlyToolTarget>();
	Target->SkeletalMesh = Cast<USkeletalMesh>(SourceObject);
	checkSlow(Target->SkeletalMesh.IsValid() && Requirements.AreSatisfiedBy(Target));

	return Target;
}

bool UTLLRN_SkeletalMeshToolTargetFactory::CanBuildTarget(UObject* SourceObject, const FToolTargetTypeRequirements& Requirements) const
{
	// We are using an exact cast here to prevent subclasses, which might not meet all
	// requirements for functionality such as the deprecated DestructibleMesh, from 
	// being caught up as valid targets.
	// If you want to make the tool target work with some subclass of USkeletalMesh,
	// just add another factory that allows that class specifically (but make sure that
	// GetMeshDescription and such work properly)
	
	const USkeletalMesh* SkeletalMesh =  ExactCast<USkeletalMesh>(SourceObject);

	return SkeletalMesh
		&& !SkeletalMesh->GetOutermost()->bIsCookedForEditor
		&& Requirements.AreSatisfiedBy(UTLLRN_SkeletalMeshToolTarget::StaticClass());
}

UToolTarget* UTLLRN_SkeletalMeshToolTargetFactory::BuildTarget(UObject* SourceObject, const FToolTargetTypeRequirements& Requirements)
{
	UTLLRN_SkeletalMeshToolTarget* Target = NewObject<UTLLRN_SkeletalMeshToolTarget>();
	Target->SkeletalMesh = Cast<USkeletalMesh>(SourceObject);
	checkSlow(Target->SkeletalMesh.IsValid() && Requirements.AreSatisfiedBy(Target));

	return Target;
}

#undef LOCTEXT_NAMESPACE

